import type { GeneratedFile } from "../types";
import type { ApiLock, ApiCommandSchema } from "../api/lock";
import type { ApiDiff, ApiCommandChange } from "../api/diff";

// ============================================================================
// Adapter Generation Types
// ============================================================================

export interface AdapterInfo {
  commandName: string;
  fromVersion: string;
  toVersion: string;
  parameterChanges: {
    kind: "added" | "removed" | "modified";
    parameterName: string;
    oldType?: string;
    newType?: string;
    wasOptional?: boolean;
    isOptional?: boolean;
  }[];
}

// ============================================================================
// Adapter Generation
// ============================================================================

/**
 * Generate type definitions for old and new versions of a command
 */
function generateCommandTypes(
  commandName: string,
  oldVersion: string,
  newVersion: string,
  oldCommand: ApiCommandSchema,
  newCommand: ApiCommandSchema
): string {
  const safeName = commandName.replace(".", "_");

  const oldParams = oldCommand.parameters
    .map((p) => `  ${p.name}${p.optional ? "?" : ""}: ${p.type};`)
    .join("\n");

  const newParams = newCommand.parameters
    .map((p) => `  ${p.name}${p.optional ? "?" : ""}: ${p.type};`)
    .join("\n");

  return `type ${safeName}_${oldVersion}_Input = {
  id: string;
${oldParams}
};

type ${safeName}_${newVersion}_Input = {
  id: string;
${newParams}
};`;
}

/**
 * Generate adapter function stub for a command
 */
function generateAdapterStub(info: AdapterInfo): string {
  const safeName = info.commandName.replace(".", "_");
  const funcName = `adapt_${safeName}_${info.fromVersion}_to_${info.toVersion}`;

  const todoComments: string[] = [];
  for (const change of info.parameterChanges) {
    switch (change.kind) {
      case "added":
        if (!change.isOptional) {
          todoComments.push(
            `  // TODO: Provide value for new required parameter '${change.parameterName}' (${change.newType})`
          );
        }
        break;
      case "removed":
        todoComments.push(
          `  // NOTE: Parameter '${change.parameterName}' was removed in ${info.toVersion}`
        );
        break;
      case "modified":
        todoComments.push(
          `  // TODO: Convert '${change.parameterName}' from ${change.oldType} to ${change.newType}`
        );
        break;
    }
  }

  return `export function ${funcName}(
  input: ${safeName}_${info.fromVersion}_Input
): ${safeName}_${info.toVersion}_Input {
${todoComments.join("\n")}
  return {
    id: input.id,
    // Add transformed parameters here
  } as ${safeName}_${info.toVersion}_Input;
}`;
}

/**
 * Generate adapter file for a version transition
 */
export function generateAdapterFile(
  fromVersion: string,
  toVersion: string,
  oldLock: ApiLock,
  newLock: ApiLock,
  breakingChanges: ApiCommandChange[]
): GeneratedFile | null {
  if (breakingChanges.length === 0) {
    return null;
  }

  const lines: string[] = [
    `/**`,
    ` * API Adapters: ${fromVersion} -> ${toVersion}`,
    ` * Generated by spitestack compiler`,
    ` *`,
    ` * These adapters transform requests from the old API version to the new version.`,
    ` * IMPORTANT: Complete the TODO items in each adapter function.`,
    ` */`,
    ``,
  ];

  const adapters: AdapterInfo[] = [];

  for (const cmdChange of breakingChanges) {
    const oldCommand = oldLock.commands[cmdChange.commandName];
    const newCommand = newLock.commands[cmdChange.commandName];

    if (!oldCommand || !newCommand) {
      continue;
    }

    // Generate type definitions
    lines.push(
      generateCommandTypes(
        cmdChange.commandName,
        fromVersion,
        toVersion,
        oldCommand,
        newCommand
      )
    );
    lines.push("");

    // Collect adapter info
    const info: AdapterInfo = {
      commandName: cmdChange.commandName,
      fromVersion,
      toVersion,
      parameterChanges: cmdChange.parameterChanges.map((p) => ({
        kind: p.kind,
        parameterName: p.parameterName,
        oldType: p.oldType,
        newType: p.newType,
        wasOptional: p.wasOptional,
        isOptional: p.isOptional,
      })),
    };

    adapters.push(info);

    // Generate adapter stub
    lines.push(generateAdapterStub(info));
    lines.push("");
  }

  // Generate adapter registry
  lines.push(`/**`);
  lines.push(` * Registry of adapters for ${fromVersion} -> ${toVersion}`);
  lines.push(` */`);
  lines.push(`export const adapters_${fromVersion}_to_${toVersion} = {`);
  for (const info of adapters) {
    const safeName = info.commandName.replace(".", "_");
    lines.push(
      `  "${info.commandName}": adapt_${safeName}_${info.fromVersion}_to_${info.toVersion},`
    );
  }
  lines.push(`};`);
  lines.push("");

  return {
    path: `adapters/${fromVersion}_to_${toVersion}.adapter.ts`,
    content: lines.join("\n"),
  };
}

/**
 * Generate all adapter files for version transitions
 */
export function generateAdapterFiles(
  versionLocks: Map<string, ApiLock>,
  diff: ApiDiff
): GeneratedFile[] {
  const files: GeneratedFile[] = [];

  // For now, this is a placeholder. In a full implementation,
  // we would generate adapters between each version transition.
  // This requires tracking multiple API lock versions.

  return files;
}

/**
 * Generate an index file that exports all adapters
 */
export function generateAdapterIndexFile(
  versionTransitions: { from: string; to: string }[]
): GeneratedFile {
  const exports = versionTransitions.map(
    ({ from, to }) => `export * from "./${from}_to_${to}.adapter";`
  );

  return {
    path: "adapters/index.ts",
    content: `/**
 * API Adapter exports
 * Generated by spitestack compiler
 */

${exports.join("\n")}
`,
  };
}
