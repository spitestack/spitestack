// Generated handlers for Counter
// DO NOT EDIT - this file is generated by spite-compiler

import type { SpiteDB, StoredEvent } from "../runtime/spitedb.js";
import { Counter } from "../../domain/counter.js";
import type { CounterEvent } from "../../domain/counter.js";
import { validateIncrement } from "../validators/counter.validator.js";
import { validateDecrement } from "../validators/counter.validator.js";
import { validateReset } from "../validators/counter.validator.js";

/**
 * Result of executing a command.
 */
export interface CommandResult {
  /** Stream ID of the aggregate */
  streamId: string;
  /** Current revision after command execution */
  revision: number;
  /** Number of events appended by this command */
  eventsAppended: number;
}

async function handleIncrement(
  streamId: string,
  input: unknown,
  db: SpiteDB
): Promise<CommandResult> {
  const validated = validateIncrement(input);

  // Load aggregate from event store
  const storedEvents = await db.readStream(streamId);
  const aggregate = new Counter();

  // Replay events to rebuild state
  for (const storedEvent of storedEvents) {
    aggregate.apply(storedEvent.data as CounterEvent);
  }

  // Execute command (may emit events)
  aggregate.increment(validated.amount);

  // Persist new events
  if (aggregate.events.length > 0) {
    const inputEvents = aggregate.events.map((event) => ({
      type: event.type,
      data: event,
    }));

    // Use optimistic concurrency: expected revision is the last event we saw
    const expectedRevision = storedEvents.length > 0
      ? storedEvents[storedEvents.length - 1]!.revision
      : -1;

    await db.append(streamId, inputEvents, { expectedRevision });
  }

  return {
    streamId,
    revision: storedEvents.length + aggregate.events.length - 1,
    eventsAppended: aggregate.events.length,
  };
}

async function handleDecrement(
  streamId: string,
  input: unknown,
  db: SpiteDB
): Promise<CommandResult> {
  const validated = validateDecrement(input);

  // Load aggregate from event store
  const storedEvents = await db.readStream(streamId);
  const aggregate = new Counter();

  // Replay events to rebuild state
  for (const storedEvent of storedEvents) {
    aggregate.apply(storedEvent.data as CounterEvent);
  }

  // Execute command (may emit events)
  aggregate.decrement(validated.amount);

  // Persist new events
  if (aggregate.events.length > 0) {
    const inputEvents = aggregate.events.map((event) => ({
      type: event.type,
      data: event,
    }));

    // Use optimistic concurrency: expected revision is the last event we saw
    const expectedRevision = storedEvents.length > 0
      ? storedEvents[storedEvents.length - 1]!.revision
      : -1;

    await db.append(streamId, inputEvents, { expectedRevision });
  }

  return {
    streamId,
    revision: storedEvents.length + aggregate.events.length - 1,
    eventsAppended: aggregate.events.length,
  };
}

async function handleReset(
  streamId: string,
  
  db: SpiteDB
): Promise<CommandResult> {
  

  // Load aggregate from event store
  const storedEvents = await db.readStream(streamId);
  const aggregate = new Counter();

  // Replay events to rebuild state
  for (const storedEvent of storedEvents) {
    aggregate.apply(storedEvent.data as CounterEvent);
  }

  // Execute command (may emit events)
  aggregate.reset();

  // Persist new events
  if (aggregate.events.length > 0) {
    const inputEvents = aggregate.events.map((event) => ({
      type: event.type,
      data: event,
    }));

    // Use optimistic concurrency: expected revision is the last event we saw
    const expectedRevision = storedEvents.length > 0
      ? storedEvents[storedEvents.length - 1]!.revision
      : -1;

    await db.append(streamId, inputEvents, { expectedRevision });
  }

  return {
    streamId,
    revision: storedEvents.length + aggregate.events.length - 1,
    eventsAppended: aggregate.events.length,
  };
}

/**
 * Creates handlers for Counter.
 */
export function createCounterHandlers(db: SpiteDB) {
  return {
    increment: handleIncrement,
    decrement: handleDecrement,
    reset: handleReset
  };
}
