/**
 * Projection interface and metadata definitions.
 *
 * Users write pure projection classes with a build() method.
 * The compiler generates metadata and factory functions that conform to these interfaces.
 *
 * @example
 * ```ts
 * // User writes:
 * class TotalRevenue {
 *   private total = 0;
 *
 *   build(event: OrderCompleted | RefundIssued) {
 *     if (event.type === 'OrderCompleted') {
 *       this.total += event.data.amount;
 *     } else {
 *       this.total -= event.data.amount;
 *     }
 *   }
 *
 *   getTotal(): number {
 *     return this.total;
 *   }
 * }
 *
 * // Compiler generates registration with metadata + factory
 * ```
 */

import type { StoredEvent } from '../../domain/events/stored-event';
import type { ProjectionStore } from './projection-store';

/**
 * Projection kind determines storage strategy.
 *
 * - aggregator: Memory-only, single value state (totals, averages)
 * - denormalized_view: Key-value store with optional disk spillover (user profiles, orders, time-series buckets)
 */
export type ProjectionKind = 'aggregator' | 'denormalized_view';

/**
 * Access pattern for a query method.
 *
 * Used to create indexes for efficient queries.
 * Derived from public methods on the projection class.
 */
export interface AccessPattern {
  /** Method name (e.g., "getById", "getByCustomerId") */
  methodName: string;
  /**
   * Fields used in equality lookups.
   * Empty for aggregator queries (getTotal).
   */
  indexFields: string[];
  /**
   * If true, uses SortedIndex for range queries (time-series style).
   * Detected when method has start/end parameters.
   */
  isRange?: boolean;
}

/**
 * Projection metadata generated by the compiler.
 *
 * Describes the projection's type, subscriptions, and access patterns.
 * Used by the runtime to configure storage and indexing.
 */
export interface ProjectionMetadata {
  /** Unique projection name (e.g., "TotalRevenue", "UserProfiles") */
  name: string;
  /** Projection type (determines storage strategy) */
  kind: ProjectionKind;
  /** Event types this projection subscribes to */
  subscribedEvents: string[];
  /** Query access patterns for index creation */
  accessPatterns: AccessPattern[];
  /**
   * Checkpoint interval hint in milliseconds.
   * Default: 5000ms. Actual interval includes jitter to avoid write storms.
   */
  checkpointIntervalMs?: number;
}

/**
 * Runtime projection interface.
 *
 * The compiler generates a factory that adapts user classes to this interface.
 * This allows the runtime to manage projection lifecycle without knowing
 * the internal structure of user classes.
 *
 * @typeParam TState - The serializable state type for checkpointing
 */
export interface Projection<TState = unknown> {
  /**
   * Build state from an event.
   *
   * Called for each event this projection subscribes to.
   * Must be a pure function of current state + event.
   *
   * @param event - The stored event to process
   */
  build(event: StoredEvent): void;

  /**
   * Apply an event directly to the backing store.
   *
   * Implement this for denormalized views to avoid rebuilding
   * the entire store on each checkpoint.
   */
  applyToStore?(event: StoredEvent, store: ProjectionStore<TState>): void;

  /**
   * Get current state for checkpointing.
   *
   * The returned state must be serializable with msgpack.
   */
  getState(): TState;

  /**
   * Restore state from a checkpoint.
   *
   * Called during recovery before replaying events.
   *
   * @param state - Previously checkpointed state
   */
  setState(state: TState): void;

  /**
   * Reset to initial state.
   *
   * Called when rebuilding the projection from scratch.
   */
  reset(): void;
}
