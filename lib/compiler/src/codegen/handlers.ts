/**
 * Generates HTTP handlers that wire aggregates to SpiteDB.
 */

import type { AggregateIR, CommandIR } from "../ir/index.js";
import { toSnakeCase, toPascalCase } from "./ts-types.js";

/**
 * Generates handlers for an aggregate.
 */
export function generateHandlers(aggregate: AggregateIR, domainImportPath: string): string {
  const snakeName = toSnakeCase(aggregate.name);
  const pascalName = toPascalCase(aggregate.name);

  // Fix: Use flat file structure (counter.js, not counter/aggregate.js)
  // Fix: Use actual class name (Counter, not CounterAggregate)
  const imports = `// Generated handlers for ${aggregate.name}
// DO NOT EDIT - this file is generated by spite-compiler

import type { SpiteDB, StoredEvent } from "../runtime/spitedb.js";
import { ${aggregate.name} } from "${domainImportPath}/${snakeName}.js";
import type { ${aggregate.events.name} } from "${domainImportPath}/${snakeName}.js";
${aggregate.commands.map((cmd) =>
  `import { validate${toPascalCase(cmd.name)} } from "../validators/${snakeName}.validator.js";`
).join("\n")}

/**
 * Result of executing a command.
 */
export interface CommandResult {
  /** Stream ID of the aggregate */
  streamId: string;
  /** Current revision after command execution */
  revision: number;
  /** Number of events appended by this command */
  eventsAppended: number;
}`;

  const handlers = aggregate.commands.map((cmd) => generateCommandHandler(aggregate, cmd));

  const createHandlers = `
/**
 * Creates handlers for ${aggregate.name}.
 */
export function create${pascalName}Handlers(db: SpiteDB) {
  return {
${aggregate.commands.map((cmd) => `    ${cmd.name}: handle${toPascalCase(cmd.name)}`).join(",\n")}
  };
}`;

  return `${imports}

${handlers.join("\n\n")}
${createHandlers}
`;
}

/**
 * Generates a handler for a command.
 */
function generateCommandHandler(aggregate: AggregateIR, cmd: CommandIR): string {
  const pascalName = toPascalCase(cmd.name);
  const hasParams = cmd.parameters.length > 0;

  const roles = cmd.roles ?? [];
  const accessComment = cmd.access !== "internal"
    ? `// Access: ${cmd.access}${roles.length > 0 ? ` (roles: ${roles.join(", ")})` : ""}\n`
    : "";

  return `${accessComment}async function handle${pascalName}(
  streamId: string,
  ${hasParams ? "input: unknown," : ""}
  db: SpiteDB
): Promise<CommandResult> {
  ${hasParams ? `const validated = validate${pascalName}(input);` : ""}

  // Load aggregate from event store
  const storedEvents = await db.readStream(streamId);
  const aggregate = new ${aggregate.name}();

  // Replay events to rebuild state
  for (const storedEvent of storedEvents) {
    aggregate.apply(storedEvent.data as ${aggregate.events.name});
  }

  // Execute command (may emit events)
  ${hasParams
    ? `aggregate.${cmd.name}(${cmd.parameters.map((p) => `validated.${p.name}`).join(", ")});`
    : `aggregate.${cmd.name}();`}

  // Persist new events
  if (aggregate.events.length > 0) {
    const inputEvents = aggregate.events.map((event) => ({
      type: event.type,
      data: event,
    }));

    // Use optimistic concurrency: expected revision is the last event we saw
    const expectedRevision = storedEvents.length > 0
      ? storedEvents[storedEvents.length - 1]!.revision
      : -1;

    await db.append(streamId, inputEvents, { expectedRevision });
  }

  return {
    streamId,
    revision: storedEvents.length + aggregate.events.length - 1,
    eventsAppended: aggregate.events.length,
  };
}`;
}
