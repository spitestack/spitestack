/**
 * Generates a complete Bun.serve server.
 */

import type { DomainIR } from "../ir/index.js";
import { toSnakeCase, toPascalCase } from "./ts-types.js";

/**
 * Generates the server file.
 */
export function generateServer(domain: DomainIR): string {
  const imports = generateServerImports(domain);
  const main = generateMainFunction(domain);

  return `${imports}

${main}
`;
}

/**
 * Generates import statements for the server.
 */
function generateServerImports(domain: DomainIR): string {
  const handlerImports = domain.aggregates
    .map((agg) => {
      const snakeName = toSnakeCase(agg.name);
      const pascalName = toPascalCase(agg.name);
      return `import { create${pascalName}Handlers, type CommandResult } from "./handlers/${snakeName}.handlers.js";`;
    })
    .join("\n");

  return `// Generated server
// DO NOT EDIT - this file is generated by spite-compiler

import { SpiteDB, ConcurrencyError } from "./runtime/spitedb.js";

${handlerImports}`;
}

/**
 * Generates the main server function.
 */
function generateMainFunction(domain: DomainIR): string {
  // Declare handler variables in outer scope
  const handlerDeclarations = domain.aggregates
    .map((agg) => {
      const snakeName = toSnakeCase(agg.name);
      return `let ${snakeName}Handlers: ReturnType<typeof create${toPascalCase(agg.name)}Handlers>;`;
    })
    .join("\n");

  const handlerSetup = domain.aggregates
    .map((agg) => {
      const snakeName = toSnakeCase(agg.name);
      const pascalName = toPascalCase(agg.name);
      return `  ${snakeName}Handlers = create${pascalName}Handlers(db);`;
    })
    .join("\n");

  const routeMatches = generateRouteMatches(domain);

  return `const PORT = Number(process.env["PORT"]) || 3000;
const DB_PATH = process.env["SPITEDB_PATH"] || "./data";

let db: SpiteDB;
${handlerDeclarations}

async function handleRequest(request: Request): Promise<Response> {
  const url = new URL(request.url);
  const method = request.method;
  const path = url.pathname;

  // Health check endpoint
  if (method === "GET" && path === "/health") {
    return Response.json({ status: "ok" });
  }

  // Parse route: POST /api/{aggregate}/:streamId/{command}
  const match = path.match(/^\\/api\\/([a-z_]+)\\/([^/]+)\\/([a-z_]+)$/);
  if (!match || method !== "POST") {
    return Response.json({ error: "Not Found" }, { status: 404 });
  }

  const [, aggregateName, streamId, commandName] = match;

  try {
    // Parse request body
    let input: unknown = undefined;
    const contentType = request.headers.get("content-type");
    if (contentType?.includes("application/json")) {
      const text = await request.text();
      if (text.trim()) {
        input = JSON.parse(text);
      }
    }

    // Route to handler
${routeMatches}

    return Response.json({ error: "Not Found" }, { status: 404 });
  } catch (error) {
    // Handle domain errors
    if (error instanceof ConcurrencyError) {
      return Response.json(
        { error: error.message, expected: error.expected, actual: error.actual },
        { status: 409 }
      );
    }

    // Handle validation errors
    if (error instanceof Error) {
      if (error.message.includes("validation") || error.message.includes("Invalid")) {
        return Response.json({ error: error.message }, { status: 400 });
      }
      // Likely a business rule error from the aggregate
      return Response.json({ error: error.message }, { status: 400 });
    }

    // Unknown error
    console.error("Unhandled error:", error);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

async function main() {
  console.log("Opening SpiteDB at", DB_PATH);
  db = await SpiteDB.open(DB_PATH);

${handlerSetup}

  console.log(\`Starting server on port \${PORT}...\`);

  const server = Bun.serve({
    port: PORT,
    fetch: handleRequest,
  });

  console.log(\`Server running at http://localhost:\${server.port}\`);

  // Graceful shutdown
  const shutdown = async (signal: string) => {
    console.log(\`\\nReceived \${signal}, shutting down...\`);
    server.stop();
    await db.close();
    console.log("Shutdown complete");
    process.exit(0);
  };

  process.on("SIGINT", () => shutdown("SIGINT"));
  process.on("SIGTERM", () => shutdown("SIGTERM"));
}

main().catch((error) => {
  console.error("Failed to start server:", error);
  process.exit(1);
});`;
}

/**
 * Generates route matching code.
 */
function generateRouteMatches(domain: DomainIR): string {
  const routes: string[] = [];

  for (const agg of domain.aggregates) {
    const snakeName = toSnakeCase(agg.name);

    routes.push(`    if (aggregateName === "${snakeName}") {`);

    for (const cmd of agg.commands) {
      const hasParams = cmd.parameters.length > 0;
      routes.push(`      if (commandName === "${cmd.name}") {`);
      if (hasParams) {
        routes.push(`        const result = await ${snakeName}Handlers.${cmd.name}(streamId!, input, db);`);
      } else {
        routes.push(`        const result = await ${snakeName}Handlers.${cmd.name}(streamId!, db);`);
      }
      routes.push(`        return Response.json(result);`);
      routes.push(`      }`);
    }

    routes.push(`    }`);
  }

  return routes.join("\n");
}
