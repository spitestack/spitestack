/**
 * Generates runtime validators for commands.
 */

import type { AggregateIR, CommandIR, DomainType, ParameterIR } from "../ir/index.js";
import { toSnakeCase, typeToTs } from "./ts-types.js";

/**
 * Generates validators for an aggregate.
 */
export function generateValidators(aggregate: AggregateIR, domainImportPath: string): string {
  const imports = generateImports(aggregate, domainImportPath);
  const validators = aggregate.commands.map((cmd) => generateCommandValidator(cmd));

  return `${imports}

${validators.join("\n\n")}
`;
}

/**
 * Generates import statements.
 */
function generateImports(aggregate: AggregateIR, domainImportPath: string): string {
  const snakeName = toSnakeCase(aggregate.name);
  return `// Generated validators for ${aggregate.name}
// DO NOT EDIT - this file is generated by spite-compiler

import type { ${aggregate.name}State, ${aggregate.events.name} } from "${domainImportPath}/${snakeName}/index.js";`;
}

/**
 * Generates a validator for a command.
 */
function generateCommandValidator(cmd: CommandIR): string {
  const paramChecks = cmd.parameters.map((p) => generateParamCheck(p));

  return `/**
 * Validates input for ${cmd.name} command.
 */
export function validate${toPascalCase(cmd.name)}(input: unknown): ${generateInputType(cmd)} {
  if (typeof input !== 'object' || input === null) {
    throw new Error('Input must be an object');
  }
  const obj = input as Record<string, unknown>;

${paramChecks.join("\n\n")}

  return {
${cmd.parameters.map((p) => `    ${p.name}: validated_${p.name}`).join(",\n")}
  };
}`;
}

/**
 * Generates the input type for a command.
 */
function generateInputType(cmd: CommandIR): string {
  if (cmd.parameters.length === 0) {
    return "Record<string, never>";
  }
  const fields = cmd.parameters.map((p) => `${p.name}: ${typeToTs(p.type)}`);
  return `{ ${fields.join("; ")} }`;
}

/**
 * Generates a parameter check.
 */
function generateParamCheck(param: ParameterIR): string {
  const name = param.name;
  const check = generateTypeCheck(param.type, `obj.${name}`, name);
  return `  // Validate ${name}
  ${check}
  const validated_${name} = obj.${name} as ${typeToTs(param.type)};`;
}

/**
 * Generates a type check expression.
 */
function generateTypeCheck(type: DomainType, expr: string, name: string): string {
  switch (type.kind) {
    case "string":
      return `if (typeof ${expr} !== 'string') {
    throw new Error('${name} must be a string');
  }`;
    case "number":
      return `if (typeof ${expr} !== 'number') {
    throw new Error('${name} must be a number');
  }`;
    case "boolean":
      return `if (typeof ${expr} !== 'boolean') {
    throw new Error('${name} must be a boolean');
  }`;
    case "array":
      return `if (!Array.isArray(${expr})) {
    throw new Error('${name} must be an array');
  }`;
    case "option":
      return `// ${name} is optional`;
    case "object":
      return `if (typeof ${expr} !== 'object' || ${expr} === null) {
    throw new Error('${name} must be an object');
  }`;
    case "reference":
      return `// ${name} is a ${type.name}`;
  }
}

/**
 * Converts to PascalCase.
 */
function toPascalCase(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
